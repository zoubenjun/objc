#  设计模式

本文大部分内容来源于：https://www.jianshu.com/p/e5c69c7b8c00

## 六大设计原则
1、单一职责原则（一个类只做一件事，只实现与这个相关的功能，不相关功能在别的类去实现）
2、开闭原则（对修改关闭，比如尽量定义为只读类型。对扩展开放，方便扩展，遇到新需求需要修改时，应该考虑扩展去解决而不是修改以前代码）
3、接口隔离原则（使用多个专门的协议、而不是一个庞大臃肿的协议）
4、依赖倒置原则（抽象不应该依赖于具体实现、具体实现可以依赖于抽象。调用接口感觉不到内部是如何操作的）
5、里氏替换原则（父类可以被子类无缝替换，且原有的功能不受任何影响）
6、迪米特法则（一个对象应当对其他对象尽可能少的了解，实现高聚合、低耦合）


## 抽象工厂模式
提供一个接口，用于创建与某些对象相关或依赖于某些对象的类家族，而又不需要指定它们的具体类。通过这种模式可以去除客户代码和来自工厂的具体对象细节之间的耦合关系。
类簇是一种把一个公共的抽象超类下的一些私有的具体子类组合在一起的架构。抽象超类负责声明创建私有子类实例的方法，会根据被调用方法的不同分配恰当的具体子类，每个返回的对象都可能属于不同的私有子类。

## 工厂方法模式
定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。
当一个类不知道它所必须创建的对象的类的时候。
当一个类希望由它的子类来指定它所创建的对象的时候。
当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。

## 单例模式
保证一个类仅有一个实例，并提供一个访问它的全局访问点。该类需要跟踪单一的实例，并确保没有其它实例被创建。单例类适合于需要通过单个对象访问全局资源的场合。

## 适配器模式
将一个类的接口转换成另外一个客户希望的接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

## 桥接模式
将抽象部分与它的实现部分分离，使它们都可以独立地变化。

## 代理模式
为其他对象提供一种代理以控制对这个对象的访问。
这种模式为某些对象定义接口，使其充当其它对象的代理或占位对象，目的是进行访问控制。这种模式可以用于为一个可能是远程的、创建起来开销很大的、或者需要保证安全的对象创建代表对象，并在代表对象中为其提供访问控制的场合。它在结构上和装饰模式类似，但服务于不同的目的；装饰对象的目的是为另一个对象添加行为，而代理对象则是进行访问控制。

## 命令模式
将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。请求对象将一或多个动作绑定在特定的接收者上。命令模式将发出请求的对象和接收及执行请求的对象区分开来。

## 观察者模式
这种模式定义一种对象间一对多的依赖关系，使得当一个对象的状态发生变化时，其它具有依赖关系的对象可以自动地被通知和更新。观察者模式本质上是个发布-定阅模型，主体和观察者具有宽松的耦合关系。观察和被观察对象之间可以进行通讯，而不需要太多地了解对方。

## 通知模式
Cocoa的通知机制实现了一对多的消息广播，其实现方式符合观察者模式。在这种机制中，程序里的对象将自己或其它对象添加到一或多个通知的观察者列表中，每个通知由一个全局的字符串（即通知的名称）标识。希望向其它对象发送通知的对象－也就是被观察的对象－负责创建一个通知对象，并将它发送到通知中心。通知中心则负责确定通知的观察者，并通过消息将通知发送给观察者对象。通知消息激活的方法必须遵循特定的单参数签名格式，方法的参数就是通知对象，包含通知的名称、被观察的对象、以及一个含有补充信息的字典。
通知的发送是一个同步的过程。在通知中心将通知广播给所有的观察者之前，发送对象不会再得到程序的控制权。对于异步的处理方式，控制权会在您将通知放入通知队列中之后立即返回到发送对象，当通知到达队列的顶部时，通知中心会将它广播出去。
常规的通知－也就是那些由通知中心广播的通知－只能在进程内部传播。如果您希望将通知广播给其它进程，需要使用分布式通知中心及其相关的API。
使用通知可以有很多原因。例如，借助通知机制，您可以根据程序中其它地方发生的事件改变用户界面元素显示信息的方式。或者，您可以用通知来保证文档中的对象在文档窗口关闭之前保存自己的状态。通知的一般目的是将事件通知给其它程序对象，使它们可以做出恰当的反应。
但是，通知的接收对象只能在事件发生之后进行反应，这和委托机制有显著的不同。被委托的对象有机会拒绝或修改委托对象希望进行的操作。另一方面，观察者对象不能直接影响一个即将发生的操作。

## KVO
键-值观察是使对象可以在其它对象的具体属性发生变化时得到通知的一种机制。它基于名为NSKeyValueObserving 的非正式协议。被观察的属性可以是简单的属性、一对一的关系、或者一对多的关系。键-值观察在模型-视图-控制器模式中特别重要，因为它使视图对象－通过控制器层－可以观察到模型对象的变化，因此是Cocoa绑定技术的必要组件（参见"控制器类"部分）。
Cocoa为很多NSKeyValueObserving方法提供了缺省的“自动”实现，使所有遵循该协议的对象都具有属性-观察的能力。
键-值观察和通告机制类似，但在一些重要的方面也有不同。在键-值观察中，没有为所有观察者提供变化通告的中心对象，而是将变化的通告直接传递给观察对象。还有，键-值观察直接和具体的对象属性相关联。而通告机制则更广泛地关注程序的事件。
参与键-值观察（KVO）的对象必须满足特定的要求－或者说是遵循KVO，记忆起来更为方便。对于自动观察来说，这需要满足键-值编码的要求（也称为遵循KVC），并使用遵循KVC的方法（也就是存取方法）。键-值编码是一个与自动获取和设置对象属性值有关的机制（基于相关的非正式协议）。
您可以禁用自动的观察者通告，并通过NSKeyValueObserving非正式协议及相关范畴中的方法实现手工通告，从而对KVO通告进行精化。

## 策略模式
定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。
